#include "envelope.h"

#include "cmsis_os.h"
#include "stm32746g_discovery_audio.h"

#define ENVELOPE_PREC 12
#define MAX_LEVEL (1 << ENVELOPE_PREC)

bool envelope_process_attack(voice_entry* voice);
bool envelope_process_decay(voice_entry* voice);
bool envelope_process_sustain(voice_entry* voice);
bool envelope_process_release(voice_entry* voice);

bool envelope_linear(voice_entry* voice, int32_t initial_level,
                     int32_t desired_level, uint16_t duration);
bool envelope_constant(voice_entry* voice);

void envelope_advance(voice_entry* voice, uint16_t duration,
                      envelope_stage next_stage, uint32_t initial_level);

int32_t roundf_32(float f);
uint16_t time_to_cycles(float time);
inline int32_t get_sustain_level(void);

void envelope_init() {
    current_settings.env.attack_time = 0.0f;
    current_settings.env.decay_time = 0.1f;
    current_settings.env.sustain_level = 0.5f;
    current_settings.env.release_time = 1.0f;
}

void envelope_reset(voice_entry* voice) {
    voice->env.stage = ENVELOPE_ATTACK;
    voice->env.cycles = 0;
    voice->env.level = 0;
    voice->env.released = false;
}

void envelope_process(voice_entry* voice) {
    bool bufferFilled = false;

    if (!bufferFilled && voice->env.stage == ENVELOPE_ATTACK) {
        bufferFilled = envelope_process_attack(voice);
    }
    if (!bufferFilled && voice->env.stage == ENVELOPE_DECAY) {
        bufferFilled = envelope_process_decay(voice);
    }
    if (!bufferFilled && voice->env.stage == ENVELOPE_SUSTAIN) {
        if (voice->env.released) {
            voice->env.stage = ENVELOPE_RELEASE;
        } else {
            bufferFilled = envelope_process_sustain(voice);
        }
    }
    if (!bufferFilled && voice->env.stage == ENVELOPE_RELEASE) {
        bufferFilled = envelope_process_release(voice);
    }

    if (voice->env.stage == ENVELOPE_SILENT) {
        voice->active = false;
    }
}

bool envelope_process_attack(voice_entry* voice) {
    const uint16_t duration_in_cycles =
        time_to_cycles(current_settings.env.attack_time);

    bool bufferFilled =
        envelope_linear(voice, 0, MAX_LEVEL, duration_in_cycles);
    envelope_advance(voice, duration_in_cycles, ENVELOPE_DECAY, MAX_LEVEL);

    return bufferFilled;
}

bool envelope_process_decay(voice_entry* voice) {
    const uint16_t duration_in_cycles =
        time_to_cycles(current_settings.env.decay_time);

    const int32_t sustain_level = get_sustain_level();

    bool bufferFilled =
        envelope_linear(voice, MAX_LEVEL, sustain_level, duration_in_cycles);
    envelope_advance(voice, duration_in_cycles, ENVELOPE_SUSTAIN,
                     sustain_level);

    return bufferFilled;
}

bool envelope_process_sustain(voice_entry* voice) {
    if (voice->env.level == 0) {
        voice->env.stage = ENVELOPE_RELEASE;
        voice->env.cycles = 0;
        return false;
    }
    return envelope_constant(voice);
}

bool envelope_process_release(voice_entry* voice) {
    const uint16_t duration_in_cycles =
        time_to_cycles(current_settings.env.release_time);

    const int32_t sustain_level = get_sustain_level();

    bool bufferFilled =
        envelope_linear(voice, sustain_level, 0, duration_in_cycles);
    envelope_advance(voice, duration_in_cycles, ENVELOPE_SILENT, 0);

    return bufferFilled;
}

/* Applies a (non-constant) linear envelope to the samples generated by the
   oscillator. This causes the amplitude of the generated waveform to increase
   or decrease at a constant pace. */
bool envelope_linear(voice_entry* voice, int32_t initial_level,
                     int32_t desired_level, uint16_t duration_in_cycles) {
    if (duration_in_cycles == 0)
        return false;

    const int32_t delta = desired_level - initial_level;
    const int32_t duration_in_samples =
        ((int32_t) duration_in_cycles) * VOICE_BUFFER_SIZE;

    int32_t sample_since_stage_start = voice->env.cycles * VOICE_BUFFER_SIZE;

    for (uint16_t i = 0; i < VOICE_BUFFER_SIZE; ++i) {
        const int32_t level = initial_level + delta * sample_since_stage_start /
                                                  duration_in_samples;

        int16_t sample = voice->samples[i];

        bool sign = sample < 0;
        if (sign)
            sample = -sample;

        sample = (int16_t)((sample * level) >> ENVELOPE_PREC);
        if (sign)
            sample = -sample;

        voice->samples[i] = sample;

        sample_since_stage_start++;
    }

    voice->env.level =
        initial_level + delta * sample_since_stage_start / duration_in_samples;

    return true;
}

/* Applies a constant envelope to the samples generated by the oscillator.
   The amplitude of the generated waveform is effectively scaled down, but
   doesn't change over time. */
bool envelope_constant(voice_entry* voice) {
    const int32_t level = voice->env.level;

    for (uint16_t i = 0; i < VOICE_BUFFER_SIZE; ++i) {
        int16_t sample = voice->samples[i];

        bool sign = sample < 0;
        if (sign)
            sample = -sample;

        sample = (int16_t)((sample * level) >> ENVELOPE_PREC);
        if (sign)
            sample = -sample;

        voice->samples[i] = sample;
    }

    return true;
}

/* Increments the cycle counter, advancing to the next stage if necessary. */
void envelope_advance(voice_entry* voice, uint16_t duration,
                      envelope_stage next_stage, uint32_t initial_level) {
    voice->env.cycles++;
    if (voice->env.cycles >= duration) {
        voice->env.stage = next_stage;
        voice->env.cycles = 0;
        voice->env.level = initial_level;
    }
}

int32_t roundf_32(float f) {
    if (f < 0.0f) {
        int32_t i = -((int32_t)(-f));
        return (i - f >= 0.5f) ? (i - 1) : i;
    } else {
        int32_t i = (int32_t) f;
        return (f - i >= 0.5f) ? (i + 1) : i;
    }
}

uint16_t time_to_cycles(float time) {
    return (uint16_t) roundf_32(time * AUDIO_FREQUENCY_44K / VOICE_BUFFER_SIZE);
}

inline int32_t get_sustain_level(void) {
    return roundf_32(MAX_LEVEL * current_settings.env.sustain_level);
}
